#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string>
#include <unordered_map>
#include <vector>
#include <iostream>
#include <fstream>
#include <cassert>

using namespace std;

class Expression {
public:
	virtual void print(std::ostream &out) const = 0;
	virtual Expression* der(string X) const = 0;
	virtual Expression* copy() const = 0;
	virtual int eval(const unordered_map<string, int>& values) const = 0;
	virtual ~Expression() {}
};

class Number : public Expression {
private:
	int num;
public:
	virtual void print(std::ostream& out) const override {
		out << num;
	}
	virtual Expression* der(string X) const override {
		return new Number(0);
	}
	virtual int eval(const unordered_map<string, int>& values) const override {
		return num;
	}
	virtual Expression* copy() const override {
		return new Number(num);
	}
	Number(int num0) {
		num = num0;
	}
};

class Variable : public Expression {
private:
	string var;
public:
	virtual void print(std::ostream& out) const override {
		out << var;
	}
	virtual Expression* der(string X) const override {
		if (var == X) {
			return new Number(1);
		}
		else return new Number(0);
	}
	virtual int eval(const unordered_map<string, int>& values) const override {
		return values.find(var)->second;
	}
	virtual Expression* copy() const override {
		return new Variable(var);
	}
	Variable(string var0) {
		var = var0;
	}
};

class Add : public Expression {
private:
	Expression* s1;
	Expression* s2;
public:
	virtual void print(std::ostream &out) const override {
		out << "(";
		s1->print(out);
		out << "+";
		s2->print(out);
		out << ")";
	}
	virtual Expression* der(string X) const override {
		return new Add(s1->der(X), s2->der(X));
	}
	virtual int eval(const unordered_map<string, int>& values) const override {
		return s1->eval(values) + s2->eval(values);
	}
	Add(Expression* s10, Expression* s20) {
		s1 = s10;
		s2 = s20;
	}
	virtual Expression* copy() const override {
		return new Add(s1->copy(), s2->copy());
	}
	~Add() {
		delete s1;
		delete s2;
	}
};

class Sub : public Expression {
private:
	Expression* s1;
	Expression* s2;
public:
	virtual void print(std::ostream &out) const override {
		out << "(";
		s1->print(out);
		out << "-";
		s2->print(out);
		out << ")";
	}
	virtual Expression* der(string X) const override {
		return new Sub(s1->der(X), s2->der(X));
	}
	virtual int eval(const unordered_map<string, int>& values) const override {
		return s1->eval(values) - s2->eval(values);
	}
	Sub(Expression* s10, Expression* s20) {
		s1 = s10;
		s2 = s20;
	}
	virtual Expression* copy() const override {
		return new Sub(s1->copy(), s2->copy());
	}
	~Sub() {
		delete s1;
		delete s2;
	}
};

class Mul : public Expression {
private:
	Expression* s1;
	Expression* s2;
public:
	virtual void print(std::ostream &out) const override {
		out << "(";
		s1->print(out);
		out << "*";
		s2->print(out);
		out << ")";
	}
	virtual Expression* der(string X) const override {
		return new Add(new Mul(s1->der(X), s2->copy()), new Mul(s1->copy(), s2->der(X)));
	}
	virtual int eval(const unordered_map<string, int>& values) const override {
		return s1->eval(values) * s2->eval(values);
	}
	Mul(Expression* s10, Expression* s20) {
		s1 = s10;
		s2 = s20;
	}
	virtual Expression* copy() const override {
		return new Mul(s1->copy(), s2->copy());
	}
	~Mul() {
		delete s1;
		delete s2;
	}
};

class Div : public Expression {
private:
	Expression* s1;
	Expression* s2;
public:
	virtual void print(std::ostream &out) const override {
		out << "(";
		s1->print(out);
		out << "/";
		s2->print(out);
		out << ")";
	}
	virtual Expression* der(string X) const override {
		return new Div(
			new Sub(
				new Mul(s1->der(X), s2->copy()),
				new Mul(s1->copy(), s2->der(X))
			),
			new Mul(s1->copy(), s2->copy())
		);
	}
	virtual int eval(const unordered_map<string, int>& values) const override {
		return s1->eval(values) * s2->eval(values);
	}
	Div(Expression* s10, Expression* s20) {
		s1 = s10;
		s2 = s20;
	}
	virtual Expression* copy() const override {
		return new Mul(s1->copy(), s2->copy());
	}
	~Div() {
		delete s1;
		delete s2;
	}
};

vector <string> getlex(const string& st) {
	vector <string> res;
	string lexem;
	lexem += st[0];
	for (int i = 1; i < st.length(); ++i) {
		if (isdigit(st[i - 1]) && isdigit(st[i])) {
			lexem += st[i];
		}
		else if (isalpha(st[i - 1]) && isalpha(st[i])) {
			lexem += st[i];
		}
		else {
			res.push_back(lexem);
			lexem = "";
			lexem += st[i];
		}
	}
	res.push_back(lexem);
	return res;
}

Expression* parse(vector <string>& lexs, int& pos) {
	if (isdigit(lexs[pos][0])) {
		int n;
		sscanf(lexs[pos++].c_str(), "%d", &n);
		return new Number(n);
	}

	if (isalpha(lexs[pos][0])) {
		return new Variable(lexs[pos++]);
	}

	assert(lexs[pos] == "(");
	pos++;

	Expression* e1 = parse(lexs, pos);
	char oper = lexs[pos++][0];
	Expression* e2 = parse(lexs, pos);

	assert(lexs[pos] == ")");
	pos++;

	switch (oper) {
	case '+':
		return new Add(e1, e2);
	case '-':
		return new Sub(e1, e2);
	case '*':
		return new Mul(e1, e2);
	case '/':
		return new Div(e1, e2);
	}
}

Expression* read(const string& st) {
	auto lexs = getlex(st);
	int pos = 0;
	return parse(lexs, pos);
}


int main() {
	std::ofstream fout("output.txt");
	std::ifstream fin("input.txt");

	string str;
	fin >> str;

	Expression* st = read(str);
	Expression* dst = st->der("x");

	dst->print(fout);

	delete dst;
	delete st;

	return 0;
}
