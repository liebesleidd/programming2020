#include <fstream>
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <iostream>
#include <fstream>
#include <string>
#include <thread>
#include <chrono>
#include <mutex>
#include <atomic>

using namespace std;

string RepositoryDownl = "C:\\crawler\\";
string Repositorypushl = "C:\\crawler_output\\";

class crawler {
public:
    crawler(int count, string input) : Threads_count(count), startPath(input) {
        goingtoProcessed.push(input);
        processed.insert(input);
    }

    void ThreadAddNewFile(string href) {
        lock_guard<mutex> lockGuard(contLock);
        if (processed.find(href) == processed.end()) {
            TasksAllStart++;
            goingtoProcessed.push(href);
        }
    }

    static void ThreadFileCopy(string filename) {
        ifstream in(filename);
        string outputFile = Repositorypushl + filename;
        ofstream out(outputFile);
        string input;
        out << in.rdbuf();
        in.close();
        out.close();
    }

    void ThreadProcessFile(string file) {
        {
            lock_guard<mutex> lockGuard(contLock);
            if (processed.find(file) != processed.end() && file != startPath) {
                return;
            }
        }
        ifstream in(file);
        ThreadFileCopy(file);
        string line;
        char c;
        vector<string> hrefs;

        while (in) {
            line.clear();
            c = in.get();
            if (c == '<' && in.get() == 'a') {
                while (c != '\"')
                    c = in.get();
                c = in.get();
                while (c != '\"') {
                    line += c;
                    c = in.get();
                }
                // line = "file://...."
                hrefs.push_back(line.substr(7));
            }
        }
        for (auto i : hrefs)
            ThreadAddNewFile(i);
        ThreadFileAddDone(file);
    }

    void ThreadFileAddDone(string filename) {
        lock_guard<mutex> lockGuard(contLock);
        processed.insert(filename);
    }
    pair<bool, string> ThreadGetNewFile() {
        lock_guard<mutex> guard(contLock);
        if (!goingtoProcessed.empty()) {
            string nextFile = goingtoProcessed.front();
            goingtoProcessed.pop();
            return make_pair(true, nextFile);
        }
        return make_pair(false, "");
    }

    /* void ThreadFileAddDone(string filename) {
        lock_guard<mutex> lockGuard(contLock);
    processed.insert(filename);
}
pair<bool, string> ThreadGetNewFile() {
    lock_guard<mutex> guard(contLock);
    if (!goingtoProcessed.empty()) {
        string nextFile = goingtoProcessed.front();
        goingtoProcessed.pop();
        return make_pair(true, nextFile);
    }
    return make_pair(false, "");
}
*/

    void ThreadProgram() {
        bool equal;
        do {
            equal = (TasksEnded.load() == TasksAllStart.load());
            auto file = ThreadGetNewFile();
            if (file.first) {
                ThreadProcessFile(file.second);
                TasksEnded++;
                equal = false;
            }
            {
                lock_guard<mutex> lockGuard(contLock);
                cout << processed.size() << " " << TasksAllStart.load() << " " << TasksEnded.load() << endl;
            }
        } while (!equal);
        cout << "Id of Thread = " << this_thread::get_id() << " end!" << endl;
    }

    pair<int, int> crawl() {
        cout << "Num of Threads = " << Threads_count << endl;
        this_thread::sleep_for(chrono::milliseconds(2000));

        pair<int, int> result;
        chrono::time_point<chrono::system_clock> start, end;
        start = chrono::system_clock::now();

        TasksAllStart.store(1);
        TasksEnded.store(0);
        for (int i = 0; i < Threads_count; ++i)
            threads.push_back(thread(&crawler::ThreadProgram, ref(*this)));
        for (int i = 0; i < Threads_count; ++i) {
            threads[i].join();
        }

        end = chrono::system_clock::now();
        int time = chrono::duration_cast<chrono::microseconds>(end - start).count();
        result.second = time;
        result.first = processed.size();
        return result;
    }


private:
    string startPath;
    int Threads_count;
    vector <thread> threads;
    queue <string> goingtoProcessed;
    set <string> processed;
    mutex contLock;
    atomic <int> TasksAllStart;
    atomic <int> TasksEnded;
};

int main() {
    ifstream fin("input.txt");

    string inp;

    int NumberOfThreads;
    fin >> inp >> NumberOfThreads;
    fin.close();

    crawler crawler(NumberOfThreads, inp);
    pair<int, int> result = crawler.crawl();
    ofstream fout("output.txt");

    fout << result.first << " " << result.second << " microseconds";
    fout.close();
    return 0;
}
