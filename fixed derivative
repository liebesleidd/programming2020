#include <math.h>//для деления при означивании
#include <string>
#include <fstream>

using namespace std;


class Expression {//абстрактный класс выражение
public:
	virtual Expression* derivative(std::string str) = 0;//взятие производной,где str это переменная дифференцирования
	virtual double eval(std::string str) = 0;//означивание
	virtual void scan(std::string str) = 0;//считывание выражения по строке
	virtual void print(std::ostream& out) = 0;//вывод выражения в файл
	virtual ~Expression() = 0;//чисто виртуальный деструктор
};
Expression::~Expression() {};

Expression* choose(std::string str);//хорошо бы сделать эту функцию методом класса, но реализацию
//всё равно надо будет писать после определения всех используемых классов и их конструкторов
//так что особого смысла не вижу
int found(std::string str);

class Number :public Expression
{
private:

	double num;

public:

	Number() : num(0){}

	Number(double n) : num(n) {}

	Number(const Number& other) {
		this->num = other.num;
	}

	void scan(std::string str) override {
		this->num = stoi(str);
	}

	double eval(std::string str) override {
		return num;
	}

	Expression* derivative(std::string str) override
	{
		return new Number(0);//производная от константы - ноль
	}

	void print(std::ostream& out) override
	{
		out << num;//при выводе числа в выражении скобки не ставятся
	}

};

class Variable :public Expression
{
private:

	std::string var;

public:

	Variable(): var("x"){}

	Variable(const Variable& other) {
		var = other.var;
	}

	~Variable() override {
		var.clear();
	}

	void scan(std::string str) override {
		this->var = str;
	}

	double eval(std::string str) override {
		std::string s = var + " <- ";
		size_t idx = s.find(s) + var.length() + 4;//индекс первого элемента означивания переменной

		std::string asw;//строка - значение переменной
		for (size_t i = idx; str[i] != ' ' && str[i] != ';' && str[i] != ')'; i++) {
			asw += str[i];
		}
		return stoi(asw);
	}

	Expression* derivative(std::string str) override
	{
		if (var == str)
			return new Number(1);
		else
			return new Number(0);
	}

	void print(std::ostream& out) override
	{
		out << var;
	}
};

class Add :public Expression
{
private:

	Expression* m1, * m2;

public:

	Add(): m1(nullptr), m2(nullptr){}

	Add(Expression* L1, Expression* L2) : m1(L1), m2(L2) {}

	~Add() override {
		delete m1;
		delete m2;
	}

	void scan(std::string str) override {
		int idx = found(str);//индекс знака +

		std::string s1 = str.substr(1, idx - 1);
		std::string s2 = str.substr(idx + 1, str.length() - idx - 2);

		m1 = choose(s1);
		m1->scan(s1);

		m2 = choose(s2);
		m2->scan(s2);
	}

	double eval(std::string str) override {
		return (m1->eval(str) + m2->eval(str));
	}

	Expression* derivative(std::string str) override
	{
		return new Add(m1->derivative(str), m2->derivative(str));

	}

	void print(std::ostream& out) override {
		out << "(";
		m1->print(out);
		out << "+";
		m2->print(out);
		out << ")";
	}
};

class Sub :public Expression
{
private:

	Expression* m1, * m2;

public:

	Sub() : m1(nullptr), m2(nullptr) {}

	Sub(Expression* L1, Expression* L2) : m1(L1), m2(L2) {}

	~Sub() override {
		delete m1;
		delete m2;
	}

	void scan(std::string str) override {
		int idx = found(str);//индекс знака -

		std::string s1 = str.substr(1, idx - 1);
		std::string s2 = str.substr(idx + 1, str.length() - idx - 2);

		m1 = choose(s1);
		m1->scan(s1);

		m2 = choose(s2);
		m2->scan(s2);
	}

	double eval(std::string str) override {
		return (m1->eval(str) - m2->eval(str));
	}

	Expression* derivative(std::string str) override
	{
		return new Sub(m1->derivative(str), m2->derivative(str));

	};

	void print(std::ostream& out) override {
		out << "(";
		m1->print(out);
		out << "-";
		m2->print(out);
		out << ")";
	}
};

class Mul :public Expression
{
private:

	Expression* e1;
	Expression* e2;

public:

	Mul() : e1(nullptr), e2(nullptr) {}

	Mul(Expression* L1, Expression* L2) : e1(L1), e2(L2) {}

	~Mul() override {
		delete e1;
		delete e2;
	}

	void scan(std::string str) override {
		int idx = found(str);//индекс знака *

		std::string s1 = str.substr(1, idx - 1);
		std::string s2 = str.substr(idx + 1, str.length() - idx - 2);

		e1 = choose(s1);
		e1->scan(s1);

		e2 = choose(s2);
		e2->scan(s2);
	}

	double eval(std::string str) override {
		return (e1->eval(str) * e2->eval(str));
	}

	Expression* derivative(std::string str) override
	{
		return new Add(new Mul(e1->derivative(str), e2), new Mul(e1, e2->derivative(str)));

	};

	void print(std::ostream& out) override {
		out << "(";
		e1->print(out);
		out << "*";
		e2->print(out);
		out << ")";
	}
};

class Div :public Expression
{
private:

	Expression* e1;
	Expression* e2;

public:

	Div() : e1(nullptr), e2(nullptr) {}

	Div(Expression* L1, Expression* L2) : e1(L1), e2(L2) {}

	~Div() override {
		delete e1;
		delete e2;
	}

	void scan(std::string str) {
		int idx = found(str);//индекс знака /

		std::string s1 = str.substr(1, idx - 1);
		std::string s2 = str.substr(idx + 1, str.length() - idx - 2);

		e1 = choose(s1);
		e1->scan(s1);

		e2 = choose(s2);
		e2->scan(s2);
	}

	double eval(std::string str) override {
		return (e1->eval(str) / e2->eval(str));
	}

	Expression* derivative(std::string str) override
	{
		return new Div(new Sub(new Mul(e1->derivative(str), e2), new Mul(e1, e2->derivative(str))), new Mul(e2, e2));

	};

	void print(std::ostream& out) override {
		out << "(";
		e1->print(out);
		out << ")" << "/" << "(";
		e2->print(out);
		out << ")";
	}
};


Expression* choose(std::string str) {
	size_t idx = found(str);

	Expression* i;
	//определяем основной класс выражения по знаку
	if (str[idx] == '+')
		i = new Add();

	else if (str[idx] == '-')
		i = new Sub();

	else if (str[idx] == '*')
		i = new Mul();

	else if (str[idx] == '/')
		i = new Div();

	else if (idx == 0)
		i = new Number();

	else
		i = new Variable();

	return i;
}


int found(std::string str) {//ищет индекс знака операции
	size_t a = 0, b = 0, i = 0;
	if (str[0] != '(') {
		if ((int)str[i] > 43 && (int)str[i] < 58)
			return 0;//если передали число
		return 1;//если передали переменную
	}
	for (; a - b != 1 || str[i] == '('; i++) {//находим место в строке, где начинается сама операция
		if (str[i] == '(')
			a++;
		if (str[i] == ')')
			b++;
	}
	for (; str[i] != ')'; i++) {
		if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/')
			return i;
	}
}

int main()
{
	std::ifstream fin{ "input.txt" };
	std::ofstream fout{ "output.txt" };

	std::string str;
	fin >> str;
	Expression* i = choose(str);
	i->scan(str);

	Expression* di = i->derivative("x");
	di->print(fout);
	fout << std::endl;

	delete i, di;

	return 0;
}
